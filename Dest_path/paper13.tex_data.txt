paper13.tex_data.txt	Defending Against Adversarial Machine Learning	{"Introduction": ["\r\n\r\nA system can defend itself against adversarial machine learners by randomly switching the feature mask it is using, by detecting unusual distributions of system inputs and reacting defensively to them, or by using other methods. Authorship attribution can be discovered using adversarial machine learning to learn the patterns between the character unigrams and authors. An adversarial machine learner can learn the mappings between system inputs and outputs and learn the Neural Network (NN) or Support Vector Machine (SVM).\r\n\r\nA defensive system can detect the system inputs from an adversarial machine learner by comparing the normal probability distribution of the inputs versus the current probability distribution\r\nof \r\nthe inputs and detecting a difference between them. If a difference is detected between the normal inputs to the system and the current inputs to the system based on the probability, then it can be assumed that the current inputs may come from an adversarial machine learner which \r\nhas learned \r\nthe inputoutput mapping to model the NN. \r\nAlso, if it is discovered that the inputs are along a certain decision boundary that the system has, then the defending system can become wary of the inputs and suspect them of being from an adversarial machine learning attacker system. \r\nSince the adversarial machine learner can develop a NN or SVM to model the syste , given the input-output mappings, the adversarial machine learning system can then use knowledge of the decision boundaries in the model to inform creating inputs that will \"trick\" the system that the adversarial machine learning system is attacking.\r\n\r\nGenerative Adversarial Networks (GANs) are a type of adversarial artificial intelligence. The discriminator operates based on a neural network that has decision boundaries and makes decisions based on inputs. The generative network, the adversary, learns the distribution in order to \"fake out\" the discriminator. Generative Adversarial Networks learn the distribution, create synthetic data, and can then trick the discriminator system and its decision boundaries. Examples of GANs tricking systems are \"deep fakes\", where an attacker creates an input to trick the decision boundaries of the original system. The analysis of variance, such as an F-test, ANOVA test, or Student t-Tes , c n be done. Then, the P-value and T-values can be analyzed to make sure that the guessed value is correct.\r\n\r\nThe seven phases in the Machine Learning Model Kill Chain are the: \r\n\r\n  * Reconnaissance (Recon) Phase\r\n\r\n  * Weaponization Phase\r\n\r\n  * Delivery Phase\r\n\r\n  * Exploitation\r\n\r\n  * Installation\r\n\r\n  * Command and Control\r\n\r\n  * Action\r\n\r\n\r\nDuring the Reconnaissance (Recon) Phase, the Machine Learning (ML) models are determined. The ML models are used to protect the defending system from the type of attacks which are to be launched by the attacking system. Then, during the Weaponization Phase, the results of probes are used in an effort to develop an attack on the defending system by learning the defending system's decision boundary. During the Decision Phase, the defending system's decision boundary is attacked by the attacking adversarial machine learning system. During the Exploitation Phase, the adversarial machine learning system gathers deeper information about the defending system's underlying model. The attacking system learns how the defending system's model will be tuned, how fast new rules can be formed, and how threats are ranked. During the Installation Phase, new rules, or features, that will allow future attacks to happen, are set up. During the Command and Control Phase, a hidden command and control channel is set up to allow for expansion of the attack. Finally, during the Action Phase, the attackers act on their main objectiveNyugen 2017.\r\n\r\n\r\n feature masks are developed, and the system switches between the \r\n feature masks to get roughly the same results. If an attacker knows the coding language that the system is written in (Python, in this case), the random generator, and the seed, then the attacker can figure out the \r\n feature masks.\r\n\r\nIf the number of features is reduced, the accuracy will increase. Feature reduction is done \r\n times to develop the \r\n feature masks. The cycle of attack by the Adversarial Author (Attacking System) and defense by the Authorship Attribution System (AAS) (Defending System) is shown in Figure ||SYMBOLTOKEN|| \r\n\r\n\r\nAcceptable ranges of drops in accuracy by the AAS whilst under attack are less than \r\n percent. The baseline accuracy of the AAS is between \r\n to \r\n percent, depending on which algorithm is being used. Therefore, an \r\n percent drop in accuracy on \r\n to \r\n percent accuracy would result in \r\n to \r\n percent accuracy. Term Frequency-Inverse Document Frequency (TFIDF) is a numerical statistic that is intended to reflect how important a letter is in a character unigram. TFIDF is used as a weighting factor in searches, and the value increases proportionally to the number of times a letter appears in the character unigram and is offset by the number of character unigrams in the set that contain the letter.\r\n\r\nWhen the simple (unweighted) Euclidean distance is used, normalization provides an equal weighting to all features, whereas some features would have more importance than others when normalization is not used. Normalization of the training data is done by subtracting the mean and dividing the mean and standard deviation of the training data.\r\n\r\nStandardization provides a way to scale the test data with the mean and standard deviation of the training data.\r\n\r\nIt is important for a defensive system to establish a sense of normalcy for inputs. A measure of normalcy is created by the algorithm knowing the distribution of normal inputs. If the distribution of the inputs has changed, a notification is made by the defensive algorithm to alert the system that there is something that has changed and the machine learning algorithm is receiving abnormal inputs. This violates the stationarity assumption, since the inputs are not normal and expected inputs. The inputs with abnormal distributions can trick the decision boundary and create bad results from the machine learning algorithm.\r\n\r\nIn machine learning, Na\u00efve Bayes classifiers are a family of simple \"probabilistic classifiers\" based on applying Bayes' theorem with strong (na\u00efve) independence assumptions between the features. They are among the simplest Bayesian network models.\r\n\r\nNa\u00efve Bayes classifiers are highly scalable, requiring a number of parameters linear in the numb r of variables (features/predictors) in a learning problem. Maximum-Likelihood training can be done by evaluating a closed-form expression, which takes linear time, rather than by expensive iterative approximation as used for many other types of classifiers.\r\n\r\nIn the statistics and computer science literature, Na\u00efve Bayes models are known under a variety of names, including simple Bayes and independent Bayes. All these names reference the use of Bayes' theorem in the classifier's decision rule, but Na\u00efve Bayes is not (necessarily) a Bayesian method.\r\n\r\nThe discussion so far has derived the independent feature model, that is, the Na\u00efve Bayes probability model. The Na\u00efve Bayes classifier combines this model with a decision rule. On  common rule is to pick the hypothesis that is most probable; this is known as the Maximum A-Posteriori (MAP) decision rule.\r\n\r\nWhen dealing with continuous data, a typical assumption is that the continuous values associated with each class are distributed according to a normal (or Gaussian) distribution. For example, suppose the training data contains a continuous attribute, \r\n. The data is first segmented by the class, and then compute the mean and variance of \r\n in each class.\r\n\r\nThe algorithms are sorted into equivalence classes based  n whether there are statistically significant differences between the algorithms. The ANOVA and Student t-Tests are used to determine statistical significance and to compare the algorithms.\r\n\r\n\r\n\r\n", {}], "Methodology": ["\r\n\r\nAn Authorship Attribution System (AAS) that is resistant to Adversarial Authorship Attacks is developed. After developing the AAS, a method for testing it is developed. The AAS reads from a file that contains the adversarial texts, called \"AdversarialTests.txt\". This file contains the list of adversarial texts that will be located in the same directory as the AAS. The \"AdversarialTests\" will contain the file names of a number of adversarial texts (advText00.txt, advText01.txt, ..., advText24.txt). The AAS reads in each adversarial text and classifies it by placing the results in a file, called \"AdversarialTestResults.txt\". The \"AdversarialTestResults.txt\" file will have a classification associated with each adversarial text of the form: \r\n\r\n  * advText00.txt \r\n\r\n  * advText01.txt \r\n\r\n  *\r\n\r\n  * advText24.txt \r\n\r\n", {"Defending System": ["\r\nPrinciple Component Analysis (PCA) may be used to reduce the number of features need for the Feature Mask to correctly identify the author. Principal Component Analysis consists of keeping the best and most effective (or highest magnitude) features and then either not using or getting rid of the other features. ||SYMBOLTOKEN|| is a function that can be used to count the number of features that are being used in the feature mask. The reduction of features results in an increase in accuracy.\r\n\r\nSwitching between Feature Masks may be used as a way to keep the attacking system from learning the decision boundaries of the defending system. Using this method, the defending system randomly switches between equivalent feature masks.\r\n\r\nUse a vector of attack criteria to decide whether or not the defending system thinks that it is being attacked. If multiple factors give positive values, then the system will determine that it must currently be under attack. Then, the defending system will respond accordingly to the perceived attack.\r\n\r\n\r\n", {}], "Attacking System": ["\r\nThe defending system may be attacked during any of the \r\n Stages of Machine Learning. The \r\n Stages of Machine Learning are: \r\n\r\n  * Measuring\r\n\r\n  * Feature Selection\r\n\r\n  * Learning Model \r\n - Lazy Learner \r\n * General Regression Neural Network (GRNN) \r\n * No Model\r\n - Support Vector Machine (SVM)\r\n - Feedforward Neural Network (FFNN))\r\n\r\n  * Training\r\n\r\n  * Prediction\r\n\r\n\r\nThere is a conditional probability, or an association, between the inputs the defending system should expect to receive and the inputs that it is actually receiving. If the system begins to receive inputs that do not match the distribution that it is expecting, then the system can recognize that the input distribution is different and react accordingly. This makes the attacking system have to then change its method of attack, in order to continue attacking the defending system in an effective manner.\r\n\r\nThe effect of feedback control on measurement noise is that the system handles measurement noise well, if the noise is Gaussian white noise. Therefore, the system may give misleading outputs. One possibility to avoid mistakes is to compute the correlation of the equation error and check whether it is white noise. The decision boundaries are \"tricked\" or \"fooled\" by modifying the input based on knowing how the system will respond to changes in the input. This is a technique used by adversarial machine learning attackers to trick a system's decision bounda ies. The defending system must find a way either to mitigate the effect of, or to recognize, the attack.\r\n\r\nThe Steady-State Genetic Algorithm (SSGA) is used to evolve the feature masks in a way that increases the accuracy. The SSGA replaces the worst fit individual in the population with the child. A population size of \r\n is used. A mutation rate of \r\n is used. There are \r\n features in each feature vector, and there are \r\n feature masks. To clarify, each feature mask is one member of the population, so there are \r\n feature masks, or population members. Binary Tournament Selection is used for selecting parents from the feature masks. Uniform Crossover is used to produce the child's features from the parents' features. \r\n", {}], "Radial Bas s Function Support Vector Machine": ["\r\n\r\nThe Radial Basis Function Support Vector Machine (RBFSVM) is implemented using scikit-learn with its default kernel being a radial basis function and this is a method whose value depends on the distance from the origin or from some point. In this paper, the output received from the processing model is then evaluated on the RBFSVM model and the accuracy is obtained.\r\n\r\n\r\n", {}], "Linear Support Vector Machine": ["\r\n\r\nThe Linear Support Vector Machine (LSVM) is implemented using scikit-learn. The LSVM is the simplest form of a support vector machine. Along with the RBFSVM, the output of the process ng model is passed through the LSVM and its accuracy is also obtained.\r\n\r\n", {}], "Feedforward Neural Network": ["\r\n\r\nThe advantages of Multi-Layer Perception (MLP) are its capability to learn nonlinear models and its c pability to learn models in real-time (online learning). There are three main disadvantages of MLP. The first disadvantage is that MLP with hidden layers has a non-convex loss function where there  xists more than one local minimum. Therefore, different random weight initializations can lead to different validation accuracy. Secondly, MLP requires tuning a number of hyper-parameters such as the number of hidden neurons, layers, and iterations. Lastly, MLP is sensitive to feature scaling.\r\n\r\nNNs may be very large, so it is impractical to write down the gradient formula by hand for all parameters. Back-propagation is the recursive application of the Chain Rule along a computational graph to compute the gradients of all inputs/parameters/intermediates. The implementations of back-propagation maintain a graph structure, where the nodes implement forward()/backward() API. The forward pass computes the result of an operation and saves any intermediates needed for gradient computation in memory. The backward pass applies the Chain Rule to compute the gradient of the loss function with respect to the inputs. \r\n", {}]}], "Experiment": ["\r\n\r\n\r\n\r\nEach author uses \r\n writing samples, and there are \r\n authors. There are thus \r\n training sets. There are \r\n letters in the alphabet which are used. A Genetic Algorithm (GA) with uniform crossover is used.\r\nThe algorithm is run \r\n times, and the best feature mask is found out of all \r\n of the runs. \r\nThe best fit individual is extracted from the character unigrams, or the number of features. \r\nThe feature consistency is the consistency of a feature being present over \r\n runs.The feature mask consists of \r\n's and \r\n's. \r\nThe feature mask multiplied by the learning set vector results in the derived learning set vector gets rid of the components that are not to be considered.\r\n\r\nFor feature selection, a population is randomly generated. The population size that is used is \r\n. The mutation rate is \r\n. There are \r\n feature vectors. The feature extraction is used to come up with the dataset, or feature set. \r\nThe fitness value is found for each feature. In each algorithm, accuracy is used for the fitness value. In other words, the accuracy for the derived training set is used for determining the fitness for each individual in the population. The evolutionary process is continued until a stopping rule is reached. Stopping rules that can be used are number of function evaluations, reaching a certain fitness value, or another stopping criteria may be used. The algorithm used in the test had a stopping rule of the limiting number of function evaluations being \r\n and the fitness value, or accuracy, reaching \r\n. This means that the algorithm must run until it reaches either the limit of \r\n function evaluations or \r\n accuracy, depending on whichever stopping limit is reached first.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", {"Radial Basis Function Support Vector Machine": ["\r\n\r\nFor the RBFSVM model, the test set is evaluated for the default values of the RBFSVM function available built into the function in scikit-learn. The function is passed with train data and train labels as parameter for training purpose. It is evaluated with the evaluation set and evaluation labels as parameters which are then used to obtain the accuracy.\r\n\r\n\r\n", {}], "Linear Support Vector Machine": ["\r\n\r\nFor the LSVM model, the linear kernel is used to process the evaluation set. The function is passed with train data and train labels as parameter for training purpose. It is then evaluated with evaluation set and evaluation labels as parameters which are used to obtain the accuracy.\r\n\r\n\r\n", {}], "Feedforward Neural Network": ["\r\n\r\nThe MultiLayer Perceptron (MLP) function is used to train the model with training data and train labels for the FFNN and then the evaluation data and evaluation labels are used to test the model for accuracy.\r\n\r\n\r\n", {}]}], "Results": ["\r\n\r\nThe ANOVA Tests gives a P-val e \r\n which suggests that the e is no statistical significant difference and has weak acceptance of hypothesis. This means that all the three models are in different equivalence classes. The Student t-Test values for all combinations of RBFSVMs, LSVMs and FFNNs have t-Stat value \r\n which suggests that the null hypothesis is accepted for each combination. The results of the statistical analysis of a comparison of all the algorithms is shown in Table ||SYMBOLTOKEN|| of Algorithms1.1\r\n\r\n\r\n\r\n@@ TABLE@@@\r\n\r\n\r\nThe results place the  hree algorithms in the same equivalence class using both the ANOVA and Studen  tTests. Whe  the ANOVA test and the Student t-Tests are performed, the ANOVA test of the three algorithms yields a p-value of 3.35E-12, so the F-Test is then performed to determine which two-tailed two-sample Student t-Test to use. In each comparison between algorithms, the Student t-Test results in a t-Stat value that is smaller than the t Critical value. Therefore, the null hypothesis is accepted.\r\n\r\n\r\nThe results from each algorithm are shown in Table ||SYMBOLTOKEN|| while the ANOVA test results are shown in Tables ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| Test Summary1.1\r\n\r\n\r\n\r\n\r\n\r\n\r\n&SS&df&MS&F&P-value&F crit\r\nBetween& 0.149 & 2 & 0.074 & 36.35 & 3.35E-12 & 3.10 \r\nWithin& 0.178 & 87 & 0.002 &  &  &  \r\nTotal& 0.326 & 89 &  &  &  &  \r\n\r\n\r\n\r\n\r\n\r\n\r\nRepresentative Student t-Tests are shown in Tables ||SYMBOLTOKEN|| and | SYMBOLTOKEN|| t-Test: Two Sample Assuming Equal Variances1.1\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n###TA LE###\r\nStudent t-Test: TwoSample Assuming Unequal Variances1.1\r\n\r\n\r\n\r\n\r\n\r\nThere are \r\n equivalence classes. The LSVM with Normalization, Standardization, and TFIDF and the FFNN with Normalization, Standardization, and TFIDF are in the same equivalence class, while the RBSVM with Normalization, Standardization, and TFIDF is in a different equivalence class.\r\n\r\n\r\nThe resulting accuracies are shown in Table ||SYMBOLTOKEN|| \r\n\r\n\r\n\r\n\r\n\r\nThe results of the statistical analysis of a comparison of all the algorithms is shown in Table ||SYMBOLTOKEN|| \r\n\r\n\r\n\r\n\r\n\r\n", {"Radial Basis Function Support Vector Machine": ["\r\n\r\nThe effect of not using TFIDF is minimal. The accuracies produced are, on average, exactly the same as the accuracies using the TFIDF.\r\nThe effect of not using Standardization is an average drop in accuracy of about 10%. If a dataset is not standardized before it is used and does not naturally have a normal distribution, then the algorithm is going to perform badly. \r\nThe effect of not using Normalization is not a large change in accuracy values. The average for 5 runs is approximately the same with and without normalization. Since the accuracies cannot be negative values, the effect of normalization on all three of the algorithms is minimal. If the dataset produced negative values, the effect would be more noticeable.\r\n\r\n\r\n", {}], "Linear Support Vector Machine": ["\r\n\r\nThe effect of not using TFIDF is basically no change to the accuracy values. The accuracies are within the same range when TFIDF is used or is not used. \r\nThe effect of not using Standardization is also an average drop in accuracy of about 10%. The StandardScalar in scikit-learn removes the mean and scales the data to unit variance. This still allows for outliers to influence the computation, and therefore does not guarantee balanced feature scales in the cases of having outliers.\r\nThe effect of not using Normalization is a drop in accuracy of about 10%. The LSVM is the most affected by not using normalized data.\r\n\r\n\r\n", {}], "Feedforward Neural Network": ["\r\n\r\nThe effect of not using TFIDF also results in no change to the accuracy values. \r\nThe effect of not using Standardization is a convergence warning. The FFNN has a maximum itera ion value of 2000, and when the data is not standardized, the optimization cannot converge in the 2000 iterations.\r\nThe effect of not using Normalization is minimal. It results in a drop of about 5%, at the most.\r\n\r\n\r\n", {}]}], "Conclusions": ["The RBFSVM, LSVM, and FFNN are all affected in similar ways when TFIDF, Standardization, and Normalization are not used. \r\nIt is evident from the ANOVA test and Student t-Test that  he LSVM and FFNN are in the same equivalence class. The FFNN had the highest average accuracy for 30 function evaluations, with an average accuracy of 72.5%. The ANOVA Test gives a P-value \r\n, which both suggests that there is no statistical significant difference and has weak acceptance of the hypothesis. This means that all the three models are in different equivalence classes. The Student t-Test values for all combinations of RBFSVMs, LSVMs and FFNNs have t-Stat value \r\n which suggests that the null hypothesis is accepted for each combination.\r\n\r\nParticle Swarm Optimization (PSO) is an option for an algorithm that may be used instead a GA and may be explored in future work.\r\n\r\n\r\n\r\n", {}], "Breakdown of the Work": ["\r\n\r\nAlison Jenkins - Research, Code, Analysis,  Report, and Extra Credit.\r\n\r\nb7 Casey, Kenan, et. al. An Evolutionary Approach for Achieving Scalability with General Regression Neural Networks. Auburn University, 2019.\r\nb4 Dozier, J. Computational Intelligence and Adversarial Machine Learning: Genetic Alg rithms. Powerpoint Presentation, COMP6970 - Computational Intelligence and Adversarial Machine Learning class, Auburn University, 2019.\r\nb5 Dozier, J. Computational Intelligence and Adversarial Machine Learning: GRNNs, RBFNs, SVMs, NNs. Powerpoint Presentation, COMP6970 - Computational Intelligence and Adversarial Machine Learning class, Auburn University, 2019.\r\nb6 Dozier, J. Computational Intelligence and Adversarial Machine Learning: Instance-Based Machine Learning. Powerpoint Presentation, COMP6970 - Computational Intellig nce and Adversarial Machine Learning class, Auburn University, 2019.\r\nb4 Dozier, G. Computational Intelligence and Adversarial Machine Learning: Particle Swarm Optimization. Powerpoint Presentation, COMP6970 - Computational Intelligence and Adversarial Machine Learning class, Auburn University, 2019.\r\nb1 Engelbrecht, Andries P. Computational Intelligence: An Introduction. John Wiley & Sons, 2007.\r\nb5 Haruna Matsushita, Yoshifumi Nishio and Chi K. Tse: Network-Structured Particle Swarm Optimizer That Considers Neighborhood Distances and Behaviors. Journal of Signal Processing, Vol.18, No.6, pp ||MATHEQUATION|| 2014.\r\nb2 Joseph, Anthony D., et al. Adversarial Machine Learning. Cambridge University Press, 2018.\r\nNyugen 2017 Nguyen, Tam N. Attacking Machine Learning Models as Part of a Cyber Kill Chain. 2017.  b3 Sarkar, Dipanjan. Text Analytics with Python. Apress, 2016.\r\nred\r\n\r\n\r\n\r\n\r\n\n", {}]}	An Adversarial System to attack and an Authorship Attribution System (AAS) to defend itself against the attacks are analyzed. Defending a system against attacks from an adversarial machine learner can be done by randomly switching between models for the system, by detecting and reacting to changes in the distribution of normal inputs, or by using other methods. Adversarial machine learning is used to identify a system that is being used to map system inputs to outputs. Three types of machine learners are using for the model that is being attacked. The machine learners that are used to model the system being attacked are a Radial Basis Function Support Vector Machine, a Linear Support Vector Machine, and a Feedforward Neural Network. The feature masks are evolved using accuracy as the fitness measure. The system defends itself against adversarial machine learning attacks by identifying inputs that do not match the probability distribution of normal inputs. The system also defends itself against adversarial attacks by randomly switching between the feature masks being used to map system inputs to outputs.
