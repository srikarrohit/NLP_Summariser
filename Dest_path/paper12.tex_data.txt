paper12.tex_data.txt	Towards Universal Languages for Tractable Ontology Mediated Query Answering	{"Introduction": ["\r\n\r\nOntology mediated query answering (OMQA) is a paradigm that generalizes the traditional database querying by enriching the database with a domain ontology PoggiLCGLR08. This paradigm has played an important role in the semantic web calvanese:DL-lite2007,lutz:ijcai05, data modelling BerardiCG05, data exchange FKMP05 and data integration Lenzerini02, and has recently emerged as one of the ce tral issues in knowledge representation as well as in databases.\r\n\r\nA long-term major topic for OMQA is to identify proper languages that specify ontologies. There have been a large number of ontology languages proposed for OMQA since the m d 2000s. For instance, in description logics, the DL-Lite family calvanese:DL-lite2007, EL-family lutz:ijcai05 and other variants have been proposed and extensively studied. More recently, the Datalog\u00b1 family, a.k.a. existential rule languages, or dependencies in databases, have been rediscovered as promising languages for OMQA, see, e.g., BLMS11,CaliGL12,CaliGP12. Most of these languages enjoy good computational properties such as the first-order rewritability or PTIME data complexity.\r\n\r\nWhile all these languages a e of their specific features and hence are useful in different applications, it is not realistic to implement OMQA-sys ems for all of them. So a natural question arises: Can we find the largest one (in the expressiveness) among the family of first-order rewritable (or PTIME-tractable) OMQA-languages? Let us call the largest language in the above sense a  universal language. Clearly, it is of great theoretical and practical importance to identify the existence of universal language w.r.t. some kind of tractability, which is also the main task of this paper.\r\n\r\nIt is worth noting that the universality is one of the major principles for designing languages in both computer science and logic. For example, almost all the traditional programming languages, including C, Java and Prolog, are known to  e universal for the f mily of Turing complete programming languages; propositional logic can express all boolean functions; and by the well-known Lindstr\u00f6m theorem the first order logic is the largest one among the logics that enjoy both the compactness and the L\u00f6wenheim-Skolem property; see, e.g., EbbinghuasFT1994. In databases, first-order language is shown to be universal for the family of query languages with data complexity in ||SYMBOLTOKEN|| and Datalog universal for the family of query languages with data complexity in PTIME; see, e.g., Immerman99.\r\n\r\nSome recent work in OMQA has been done along the line of identifying universal languages. C lvaneseGLLR13 CalvaneseGLLR13 proved that, under a certain syntactic classification, some lang ages in the DLLite family are the maximal fragments of description logic with the first-order rewritability. By regarding OMQA as traditional database querying, GRS2014 GRS2014 showed that weakly-guarded tuple-generating dependencies (TGDs) capture the class o  EXPTIME queries; RudolphT2015 RudolphT2015 proved  hat general TGDs capture the class of recursively enumerable queries. In the setting of schema mapping, ZhangZY15 ZhangZY15 showed that the language of weakly-acyclic TGDs is universal for languages of TGDs with finite semi-oblivious chase. All of these results shed new insights on understanding the expressiveness of existential rules, but it is worth noting that OMQA is significantly different from both traditional database querying and schema mapping. To understand the expressiveness in the framework of OMQA, ZhangZY16 ZhangZY16 proved that the language of disjunctive embedded dependencies is universal for the family of recursively enumerable OMQA-languages. Along this line, this paper will focus on tractable OMQA.\r\n\r\nAimed at exploiting universal languages for the tractable OMQA, in this paper we focus on three families of OMQA-languages, including first-order rewritable languages and languages whose data complexity is in ||SYMBOLTOKEN|| or PTIME. Our contributions are summarized as follows. On one hand, we prove that there is  in general, no universal language for each of the above families of languages. On the other hand, by restricting the number of database constants involved in query answering, we propose a novel property, called the  locality, to approximate the first-order rewritability, and identify the existence of universal language for the family of local OMQA-languages. All of these results hold for OMQA with query languages such as conjunctive queries, unions of conjunctive queries and acyclic conjunctive queries.\r\n\r\n\r\n", {}], "Preliminaries": ["\r\n\r\n Databases and Instances. We use a countably infinite set of  constants and a countably infinite set of  variables, and assume they are disjoint. Every  term is either a constant or a variabl . A  relational schema R consists of a set of  relation symbols. Each relation symbol has an  arity which is a natural number. An  atoms over R (or R-atom) is either an equality, or a  relational atom built upon terms and relation symbols in R. A  fact is a variable-free relational atom. Each  instance over R (or  R-instance) consists of a set of facts over R. Instances that are finite are called  databases. Suppose I is an instance. Let adom(I) denote the set of constants that oc ur in I. Let DB[R] denote the class of all databases over schema R. Given a set A of constants, by ||SYMBOLTOKEN|| we denote the subset of I in which each fact involves only constants in A.\r\n\r\nLet I and J be instances over a relational schema R, and C\u2286 adom(I)\u2229 adom(J). The  every  Chomomorphism from I to J is a function h:adom(I)\u2192 adom(J) such that (i) ||SYMBOLTOKEN|| I implies ||SYMBOLTOKEN|| J for all relation symbols ||SYMBOLTOKEN|| and all tuples a\u20d7 of constants, and (ii) ||SYMBOLTOKEN|| for all ||SYMBOLTOKEN|| C. If such h exists, we  ay tha  I is  Chomomorphic to J, and write ||SYMBOLTOKEN|| J; in addition, we write ||SYMBOLTOKEN|| J if h is injective. For simplicity, C will be dropped if it is empty.\r\n\r\n Queries. Fix R as a relational s hema. By a  query ov r R (or Rquery) we mean a formula built upon atoms over R in some logic. The logic could be first-order logic, second-order logic, or other variants. A query is  boolean if it has no free variables. For convenience, given any query q, let const(q) denote the set of constants that occur in q.\r\n\r\nEvery first-order formula is called a  first-order query. A  conjunctive query (CQ) is a query of the form ||SYMBOLTOKEN|| where ||SYMBOLTOKEN|| is a finite but nonempty conjunction of relational atoms. Let q be a boolean CQ. We use [q] to denote the database that consists of all the atoms that appear in q, where variables in atoms are regarded as special constants. The  Gaifman graph of q is an undirected graph with each term in q as a vertex, and with each pair of distinct terms as an edge if they cooccur in some atom in q. A boolean CQ is called  acyclic if its Gaifman graph is acyclic. A  union of conjunctive query (UCQ) is a first-order formula built upon atoms by connectives \u2227,\u2228 and quantifier ||SYMBOLTOKEN|| Clearly, every UCQ is equivalent to a disjunction of CQs.\r\n\r\nEvery  ||SYMBOLTOKEN|| program consists of a finite set of  rules of the form ||SYMBOLTOKEN|| where ||SYMBOLTOKEN|| is a relational atom and ||SYMBOLTOKEN|| is a finite conjunction of atoms or negated atoms; ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| are called the  head and the  body of the rule, respectively. Each variable in x\u20d7 should have at least one positive occurrence in ||SYMBOLTOKEN|| A relation symbol is called  int ntional if it has at least one occurrence in the head of some rule, and  extensional otherwise. No intensional relation symbol is allowed to appear in a negated atom. A  ||SYMBOLTOKEN|| query is of the form ||SYMBOLTOKEN|| where ||SYMBOLTOKEN|| is a ||SYMBOLTOKEN|| program, P an extensional relation symbol, and x\u20d7 a variable tuple of a proper l ngth. It is well-known that every ||SYMBOLTOKEN|| que y can be translated to a  equivalent formula in least fixpoint logic, see, e.g., EbbinghuasF95.\r\n\r\nOnly boolean queries will be used in this work.\r\nFor con enience, we employ CQ, ACQ and UCQ to denote the classes of boolean CQs, boolean acyclic CQs and boolean UCQs, respectively. Let FO denote the class of boolean first-order queries,  ||SYMBOLTOKEN|| denote the class of boolean first order queries that involve two built-in arithmetic relations ||SYMBOLTOKEN|| and \u00d7, and ||SYMBOLTOKEN|| denote the class of boolean ||SYMBOLTOKEN|| queries that involve a built-in successor relation Succ, and special constants min and max, denoting the minimum and the maximum elements, respectively, under the underlying order. Given a class C of queries and a relational schema R, let C[R] denote the class of R-queries that belong to C.\r\n\r\nIn the theory of descriptive complexity Immerman99, it was proved that ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| exactly capture complexity classes ||SYMBOLTOKEN|| and PTIME respectively, where ||SYMBOLTOKEN|| denotes the class of languages recognized by a uniform family of circuits with co stant depth and polynomial size, and PTIME denotes the class of languages recognized by a deterministic Turing machine in polynomial time.\r\n\r\n Dependencies. A  disjunctive embedded dependency (DED) over a relational schema   is a sentence ||SYMBOLTO EN|| of the ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| 0, \u03d5 is a conjunction of relational R-atoms involving terms from x\u20d7\u222ay\u20d7 only, each ||SYMBOLTOKEN|| is a conjunction of atoms over R involving terms from ||SYMBOLTOKEN|| only  and each variable in x\u20d7 has at least one occurrence in \u03d5. In particular, ||SYMBOLTOKEN|| is called a  tuple-generating dependency (TGD) if it is equality-free and ||SYMBOLTOKEN|| For simplicity, we omit the universal quantifiers and the brackets appearing outside the atoms.\r\n\r\nLet D be a database, ||SYMBOLTOKEN|| a set of (first-order) sentences, and q a boolean query; all of them are over a common relational schema R. We write ||SYMBOLTOK N|| if, for all Rinstances I with D\u2286 I, if ||SYMBOLTOKEN|| for all sentences ||SYMBOLTOKEN|| then Iq, where the satisfaction relation  is defined in the standard way.\r\n\r\n\r\n", {}], "Ontologies and Languages in OMQA": ["\r\n\r\nBefore identifying the existence of universal languages for OMQA, we nee  some notions t  clarify what an ontology in OMQA is, and what an ontology language in OMQA is. To make the presented results more applicable, we will define these notions in a language-independent way.\r\n\r\nTo define ontologies in OMQA, below we generalize the notion introduced in ZhangZY16 from CQs to more general query languages such as UCQs.\r\n\r\nLet D and Q be relational schemas, and Q a class of queries. A  quasi-OMQA[Q]-ontology over (D,Q) is a set of ordered pairs (D,q), where D is a D-database and q a boolean Q-query in Q such that const(q)\u2286adom(D).\r\n\r\nMoreover, a quasi-OMQA[Q]-ontology O over (D,Q) is called an  OMQA[Q]-ontology if all of the following hold: \r\n\r\n  * O is  closed under query conjunctions, i.e.,\r\n ||SYMBOLTOKEN|| O & ||SYMBOLTOKEN|| O & ||SYMBOLTOKEN|| O.\r\n\r\n  * O is  closed under query implications, i.e.,\r\n ||SYMBOLTOKEN|| O & ||SYMBOLTOKEN|| & q ||SYMBOLTOKEN|| O. \r\n\r\n  * O is  closed under injective database homomorphisms, i.e.,\r\n ||SYMBOLTOKEN|| O & ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| O. \r\n\r\n\r\nGiven any logical theory ||SYMBOLTOKEN|| we can interpret it as a quasi-OMQA[Q]-ontology over (D,Q) as ||SYMBOLTOKEN|| & ||SYMBOLTOKEN|| & ||SYMBOLTOKEN|| is easy to see that, for theories ||SYMBOLTOKEN|| in almost all the classical logic, ||SYMBOLTOKEN|| is indeed an OMQA[Q]-ontology.\r\n\r\nWith the notion of ontology, we are then able to present an abstract definition for ontology languages in OMQA. \r\n\r\nLet V be a finite but nonempty set, D and Q relational schemas, and Q a class of queries. Then every  OMQA[Q]-language L over (D,Q) (with vocabulary V) is defined as an ordered pair (T, M) such that:\r\n\r\n  * T consists of a decidable set of  theories, each of which is a finite string over V (i.e., an element of ||SYMBOLTOKEN |  * M is a  semantic mapping, i.e., a function that maps each theory in T to an OMQA[Q]-onto ogy over (D,Q).\r\n\r\n\r\n\r\nLet D and Q be relational schemas, Q a class of queries, and T a decidable class of finite sets of DEDs. Let M be a function that maps each set ||SYMBOLTOKEN|| T to ||SYMBOLTOKEN|| is easy to see that ||SYMBOLTOKEN|| is an OMQA[Q]-language.  \r\n\r\n \nThe language L defined above is called a  DED-language over (D,Q) (induced by T). In particular, if T consists of all finite sets of DEDs, we call it the  full DED-language over (D,Q). Unfortunately, it had been proved in Vardi1982 that query answering with the full DED-language is uncomputable. In this work, we thus focus on tractable OMQA-languages. We will consider two kinds of tractability:\r\n\r\n\r\nLet D and Q be relational schemas, C and Q classes of queries, and K a complexity class. An OMQA[Q]-language ||SYMBOLTOKEN|| over (D,Q) is \r \r\n  * Crewritable if there is a computable function rew that maps each ordered pair ||SYMBOLTOKEN|| T\u00d7Q[Q] to a boolean query ||SYMBOLTOKEN|| such that ||SYMBOLTOKEN|| iff ||SYMBOLTOKEN|| in this case, rew is called a  C-rewriting function of L.\r\n\r\n  * K-compilable if there is a computable function com that maps each ordered pair ||SYMBOLTOKEN|| T\u00d7Q[Q] to a Turing machine ||SYMBOLTOKEN|| whose running time belongs to the class K, such that ||SYMBOLTOKEN|| iff ||SYMBOLTOKEN|| accepts on the input D; in this case, com is called a  K-compiler of L.\r\n\r\n\r\n\r\nAccording to CaliGL12, the language of linear TGDs is both FO-rewritable and ||SYMBOLTOKEN|| and the language of guarded TGDs is both ||SYMBOLTOKEN|| and PTIME-compilable.\r\n\r\n\r\n\r\nClearly, there is a nonuniform way to redefine notions in Definition ||SYMBOLTOKEN|| by allowing rewriting functions and compilers to be uncomputable. However, it is worth noting that languages defined in such a way could be intractable. In fact, there is a nonuniform FO-rewritable OMQA-language in which the query answering is highly undecidable.  \r\n\r\n\r\nNext we give the definition of universal OMQA-language.\r\n\r\n\r\nLet Q be a class of queries, D and Q relational schemas, and ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| OMQA[Q]-languages over (D,Q). Then we say that L' is  at least as expressive as L, written ||SYMBOLTOKEN|| if for each theory ||SYMBOLTOKEN|| T there is a theory ||SYMBOLTOKEN|| T' such that ||SYMBOLTOKEN|| and L'  has the same expressiveness as L if both ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| OMQA[Q]-la guage L is called  universal for a family L of  OMQA[Q]-languages over (D,Q) if (i) ||SYMBOLTOKEN|| and (ii) for all languages ||SYMBOLTOKEN|| we have that ||SYMBOLTOKEN|| \r\n\r\n\r\n\r\n", {}], "Nonexistence for the General Case": ["\r\n\r\nOne ambitious goal in OMQA is to find some universal language for the tractable OMQA. Unfortunately, the following theorem shows that this goal is in general unachieva le.\r\n\r\n\r\nLet D and Q be relational schemas such that Q contains a relation symbol of arity ||SYMBOLTOKEN|| 2, and suppose ||SYMBOLTOKEN|| (+,\u00d7),Datalog^(<)} and ACQ \u2286 Q\u2286UCQ. Then there is no universal language for the family of C-rewritable OMQA[Q]-languages over (D,Q).\r\n\r\n\r\nSince ||SYMBOLTOKEN|| and PTIME are exactly captured by ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| respectively, by Theorem ||SYMBOLTOKEN|| we have\r\n\r\n\r\nLet D and Q be relational schemas such that Q contains at least one relation symbol of arity ||SYMBOLTOKEN|| 2, and suppose ||SYMBOLTOKEN|| PTIME} and ACQ \u2286 Q\u2286UCQ. Then there is no universal language for the family of K-compilable OM A[Q]languages over (D,Q).\r\n\r\n\r\n\r\n\r\nTo prove Theorem ||SYMBOLTOKEN|| the general idea is to implement   diagonalization argument as follows. Assume by contradiction that there is a universal language for the desired family. We first give an effective enumeration for all nontrivial ontologies defined in the universal language. With this enumeration, we then construct a new OMQA[Q]-ontology O and a new language L' in which O is definable; Finally we show that L' is still C-rewritable, which leads to a contradiction.\r\n\r\n\r\nOnly consider the case where ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| Assume by contradiction that there is a universal language for FO-rewritable OMQA[UCQ]-languages over (D,Q). Let ||SYMBOLTOKEN|| be such a language. Our task is to define another FO-rewritable OMQA[UCQ]-languag  that is strictly more expressive than L. To do this, we first construct an ontology that is not definable in L.\r\n\r\nBefore we present the construction, some notations are needed. W.l.o.g., we assume that there is a binary relation symbol R in Q. Note that, by a repetition of the parameters, R can be always simulated by another relation symbol of arity ||SYMBOLTOKEN|| For example, one can use S(x,x,y) to simulate R(x,y). With this assumption, we first define a sequence of acyclic CQs. For all integers ||SYMBOLTOKEN|| 1, we ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| x_n(R(x_0,x_1)\u2227...\u2227 ||SYMBOLTOKEN|| q_n asserts that there is a cycle-free path (via R) of length ||SYMBOLTOKEN|| in the intended model.\r\n\r\nLet ||SYMBOLTOKEN|| be an effective enumeration[I.e., there is a Turing machine to generate such an enumeration.] of all the theories in T. Such an enumeration clearly exists. Now our task is to construct countably infinite sequences N\u20d7 and t\u20d7, where ||SYMBOLTOKEN|| is a sequence of positive integers, and ||SYMBOLTOKEN|| is a sequence of theories in T. The sequences are required to have the following properties:\r\n\r\n  * N\u20d7 is monotonic increasing, i.e., ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| if ||SYMBOLTOKEN||  * For all ||SYMBOLTOKEN|| 1 there exists a database D with ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| ||SYMBOLTOKEN||  * For all ||SYMBOLTOKEN|| T\u2216t\u20d7 there exists ||SYMBOLTOKEN|| such that ||SYMBOLTOKEN|| for all databases D with ||SYMBOLTOKEN|| M(t). \r\n\r\n\r\nProcedure ||SYMBOLTOKEN|| is devoted to generate the desired sequences. \r\n\r\n\tn\u2190 1  i\u2190 1  \u221en\u2190 n  \u221ej\u2190 1  ||SYMBOLTOKEN|| D s.t. ||SYMBOLTOKEN|| ||SYMBOLTOKEN||   &  ||SYMBOLTOKEN|| n goto line 9\r\n\t        ||SYMBOLTOKEN|| D s.t. ||SYMBOLTOKEN|| ||SYMBOLTOKEN||   &  ||SYMBOLTOKEN|| n+1\r\n\t        \t\t\t\tn\u2190 ||SYMBOLTOKEN||   goto line 9  ||SYMBOLTOKEN|| n   ||SYMBOLTOKEN|| s_j  \r\n\t\tdelete ||SYMBOLTOKEN|| from s\u20d7  Generating Sequences t\u20d7 and N\u20d7\r\n\r\nNow we have the following property:\r\n\r\n Claim 1. The sequences N\u20d7 and t\u20d7 generated by Procedure ||SYMBOLTOKEN|| satisfy Properties (1-3).\r\n\r\n\r\nProperties 1 and 2 are clear from Procedure 1. So it remains to show Property 3.\r\nSuppose ||SYMBOLTOKEN|| for some ||SYMBOLTOKEN|| 1. Since t has no occurrence in t\u20d7, according to Procedure 1, we know that, whenever lines 5 and 6 are executed  for ||SYMBOLTOKEN|| conditions in both \"if\" statements must be false. (Otherwise we will have ||SYMBOLTOKEN|| In addition, as n increases arbitrarily, we know that line 6 must be executed. This means that there is some  ||SYMBOLTOKEN|| 1 such that ||SYMBOLTOKEN|| for all databases D with ||SYMBOLTOKEN|| M(t), which then yields the claim.  \r\n\r\n\r\n\r\nNow we are able to construct the desired ontology. To do this, we first define some notations. For ||SYMBOLTOKEN|| 1, let ||SYMBOLTOKEN|| denote the sentence ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| i<j< ||SYMBOLTOKEN|| which asserts that the intended domain contains at least n elements. Given a boolean UCQ q, if there exists an integer ||SYMBOLTOKEN|| 1 such that ||SYMBOLTOKEN|| q, let ||SYMBOLTOKEN|| denote ||SYMBOLTOKEN|| where m is the least integer among such ks, and let ||SYMBOLTOKEN|| denote the sentence ||SYMBOLTOKEN|| x(x=x) (always false) if no such ks exist. Furthermore, we define\r\n\r\n\r\n\r\nFurthermore, given an OMQA[Q]-language L, a bound function \u2113 and a class F of bound functions, L is called  \u2113-local  f  llOMQA[Q] ontologies defined in L is \u2113-local, and L is F-local if it is \u2113'-local for some bound function ||SYMBOLTOKEN|| \r\n\r\n\r\nOne might question why the bounded locality is a good ap roximation to the first-order rewritability. Let ||SYMBOLTOKEN|| denote the class of first-order sentences built on  toms and inequalities by using connectives \u2227,\u2228 and the quantifier ||SYMBO TOKEN|| Obviously, this class is exactly the class of UCQs with inequalities. It had been observed by Benedikt16 tha  ||SYMBOLTOKEN|| captures the class of first-order sentences that preserved under injective homomorphisms Benedikt16. It remains open whether such a preservation theorem holds on finite s ructures (or databases). If this is indeed true, by the following proposition we then have that an O QAlanguage is FO-rew itable iff it is \u2113-local for some bound function \u2113.\r\n\r\n\r\nLet D and Q be relational schemas, O an OMQA[UCQ]-ontology over (D,Q), and \u2113 a bound function. Then O is \u2113-local iff for each boolean Q-UCQ q there is a ||SYMBOLTOKEN|| \u03c6 involving at most \u2113(q ) terms such that ||SYMBOLTOKEN|| O iff ||SYMBOLTOKEN|| for all D-databases D.\r\n\r\n\r\n \r\nFor the direction of \"if\", let us assume that for each boolean Q-UCQ q there is a ||SYMBOLTOKEN|| \u03c6 involving at most \u2113(q ) terms such that ||SYMBOLTOKEN|| O iff ||SYMBOLTOKEN|| for all D-databases D. We need to sh w that O is \u2113-local. Let q be a boolean Q-UCQ, and ||SYMBOLTOKEN|| a ||SYMBOLTOKEN|| involving at most \u2113(q ) terms such that ||SYMBOLTOKEN|| O iff ||SYMBOLTOKEN|| for all D-databases D. By the assumption, such a sentence does exist. Suppose ||SYMBOLTOKEN|| where ||SYMBOLTOKEN|| is a quantifier-free existential positive first-order formula with inequalities and involving at most \u2113( q) terms. Let D be a D-database. If ||SYMBOLTOKEN|| then let ||SYMBOLTOKEN|| const(\u03c6), where s is an assignment such that ||SYMBOLTOKEN|| Otherwise, let A be any subset of adom(D) such that ||SYMBOLTOKEN|| k. In both cas s we have the following: (i) ||SYMBOLTOKEN|| k, and (ii) ||SYMBOLTOKEN|| iff ||SYMBOLTOKEN|| F om the latter, we know that ||SYMBOLTOKEN|| O iff ||SYMBOLTOKEN|| O. We thus yields that O is \u2113-local as desired.\r\n\r\nConversely, suppose O is \u2113-local. Let q be a boolean Q-UCQ. Given a D-database D, let A\u2286 adom(D) be a witness of the locality of O w.r.t. q, let ||SYMBOLTOKEN|| denote the conjunction of all facts in D; let ||SYMBOLTOKEN|| be the formula obtained from ||SYMBOLTOKEN|| by replacing each constant that does not occur in q by a fresh variable; and  et ||SYMBOLTOKEN|| denote the sentence ||SYMBOLTOKEN|| where x\u20d7 is the tuple of all variables occurring in ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| denotes the conjunction of ||SYMBOLTOKEN|| x_j for each pair of distinct variables ||SYMBOLTOKEN|| It is easy to see that, up to logical equivalence, there is only a finite number of ||SYMBOLTOKEN|| for all D-databases D such that ||SYMBOLTOKEN|| O. Let ||SYMBOLTOKEN|| be a disjunction of ||SYMBOLTOKEN|| for all D-databases D with ||SYMBOLTOKEN|| ) and ||SYMBOLTOKEN|| O. Clearly, ||SYMBOLTOKEN|| is equivalent to a ||SYMBO TOKEN|| that involves at most \u2113(q ) terms. To complete the proof, it suffices to show the following property:\r\n\r\n Claim. ||SYMBOLTOKEN|| O iff ||SYMBOLTOKEN|| for all databases D over D.\r\n\r\n\r\nNow it remains to prove the claim. Let D be a database over D. We first prove the direction of \"only if\". Suppose ||SYMBOLTOKEN|| O. Since O is \u2113-local, there should be a D-database D'\u2286 D such that ||SYMBOLTOKEN|| O and ||SYMBOLTOKEN|| ). By the definition of ||SYMBOLTOKEN|| we know that ||SYMBOLTOKEN|| is equivalent to a disjunct of ||SYMBOLTOKEN|| It is clear that ||SYMBOLTOKEN|| From D'\u2286 D we the have ||SYMBOLTOKEN|| which implies ||SYMBOLTOKEN|| as desired.\r\n\r\nFor the converse, we assume that ||SYMBOLTOKEN|| Then there is a database D' over D with ||SYMBOLTOKEN|| ) such that (i) ||SYMBOLTOKEN|| O and (ii) ||SYMBOLTOKEN|| is a disjunct of ||SYMBOLTOKEN|| From (ii) we have ||SYMBOLTOKEN|| which means that there is an injective C-homomorphism from D' to D, where ||SYMBOLTOKEN||  As O is closed under injective database homomorphisms, we have ||SYMBOLTOKEN|| O as desired, which completes the proof.\r\n\r\n\r\n\r\n\r\nProposition ||SYMBOLTOKEN|| reveals an intrinsic connection between the bounded locality and the complexity of rewritings. We will elaborate th s in an extended version of this paper.\r\n\r\n\r\n\r\n", {"Universal Language for Local OMQA": ["\r\n\r\nNow it remains to know whether the bounded locality allows the existence of universal languages. For convenience, in the rest of this section, we  fix F as a decidable class of bound functions; fix D and Q as a pair of disjoint relational schemas. The disjointness will not introduce any real limitation. F r instance, in a DED-language, given any set ||SYMBOLTOKEN|| of DEDs, one can construct another set ||SYM OLTOKEN|| of DEDs by introducing a fresh relation symbol R' for each ||SYMBOLTOKEN|| and adding copy rules of the form R'(x\u20d7)\u2192R(x\u20d7). Clearly, ||SYMBOLTOKEN|| has the same behaviour over (D',Q) as ||SYMBOLTOKEN|| over (D,Q), where D' denotes the schema consisting of all the fresh symbols.\r\n\r\nSurprisingly, we have the following result.\r\n\r\n\r\nLet Q be a decidable class of UCQs. Then there exists a DED-language that is universal for the family of F-local OMQA[Q]-languages over (D,Q).\r\n\r\n\r\nLet \u2113 be any bound function in F. To prove Theorem ||SYMBOLTOKEN|| the general idea is to develop a transformation that converts every DED set to an \u2113-local DED set. In addition, for each DED set that is already \u2113-local, the transformation is  equired to preserve the semantics of query answering. If such a tran formation exists, since DED is universal for the family of OMQA-languages in which query answering is recursively enumerable, we then obtain a universal language for the family of F-local OMQA-languages.\r\n\r\nLet us begi  with a finite set ||SYMBOLTOKEN|| of DEDs over a relational schema R\u2287D\u222aQ. To implement the desired transformation, we first show how to construct an \u2113-local OMQA[Q]-ontology from ||SYMBOLTOKEN|| As a natural idea, one may expect to define the desired ontology by removing all the pairs (D,q) from the original ontology (defined by ||SYMBOLTOKEN|| where q is not \u2113-local on D. Unfortunately, the ontology defined above is in general not well-defined. To construct the desired ontology, the \u2113-locality and the closure under both query conjunctions and query implications should be maintained simultaneously.\r\n\r\nBelow we explain how to construct the ontology. We need to fix a strict linear order \u227a over Q-UCQs firstly. The strict linear order is required to satisfy p\u227a q for all Q-UCQs p and q such that  ||SYMBOLTOKEN|| q. Clearly, such an order always exists. For the given set ||SYMBOLTOKEN|| of DEDs, let ||SYMBOLTOKEN|| be the set that consists of the ordered pair (D,q) if D is a D-database, q is a Q-UCQ in Q, and the following condition holds:\r\n\r\n\r\nwhere pr(q) is the set of boolean UCQs p such that p\u227a q and ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| and pr(q) denotes the conjunction of q and all UCQs in pr(q). Moreover, we define ||SYMBOLTOKEN|| as the minimum superset of ||SYMBOLTOKEN|| that is closed under query conjunctions, query implications and injective database homomorphisms.\r\n\r\nThe constructed ontology enjoys several properties which will play important roles in our proof for Theorem ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| is \u2113-local, then ||SYMBOLTOKEN|| from the definition of ||SYMBOLTOKEN|| is an \u2113-local OMQA[Q]-ontology.\r\n\r\n\r\n\r\nWe first claim that, for all UCQs q with ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| there exists an integer ||SYMBOLTOKEN|| 1 and UCQs ||SYMBOLTOKEN|| such that ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| for each ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| p_k q. This can be proved by a routine induction of the construction of ||SYMBOLTOKEN|| the claim, w.l.o.g., we assume ||SYMBOLTOKEN|| p_2\u227a...\u227a ||SYMBOLTOKEN|| Let p denote the query ||SYMBOLTOKEN|| p_k. Obviously, it holds that ||SYMBOLTOKEN|| p, which implies that ||SYMBOLTOKEN|| q immediately. On the other hand, by definition we know that ||SYMBOLTOKEN|| is \u2113-local on D, i.e., there is a set ||SYMBOLTOKEN|| adom(D)  uch that ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| Let ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| We then have ||SYMBOLTOKEN|| p and ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| p).\r\nConsequently, we obtain that p is \u2113-local on D.\r\n\r\nNow, it remains to show that q is \u2113-local on D. For the case where  ||SYMBOLTOKEN|| q, from p q and ||SYMBOLTOKEN|| p, we obtain that ||SYMBOLTOKEN|| q, which implies that q is \u2113-local on D. For the other case, it must be true that  ||SYMBOLTOKEN|| q. From the fact that ||SYMBOLTOKEN|| p, we know that ||SYMBOLTOKEN|| q. Since ||SYMBOLTOKEN|| ||SYMBOLTOKEN|| is true, by Condition ||SYMBOLTOKEN|| we know that there is a set B\u2286 adom(D) such that ||SYMBOLTOKEN|| q, which means that q is \u2113-local on D. This then completes the ||SYMBOLTOKEN|| is recursively enumerable. \r\n\r\n\r\n\r\nThe lemma is a corollary of the following facts:\r\n(1) The validity problem for inference in first-order logic is recursively enumerable;\r\n(2) The query containment problem for UCQs is decidable;\r\n(3) There are only a finite number of boolean Q-UCQs p with  ||SYMBOLTOKEN|| \r\n(4) There are only a finite number of subsets of adom(D).\r\n(5) Both \u2113 and \u00b7 are computable.\r\n(6) Q is decidable.\r\n\r\n\r\nNow, to define the transformation, it remains to show how to encode the ontology ||SYMBOLTOKEN|| by another set of DEDs. Suppose D is the underlying database, and q the underlying query. The encoding will be implemented in the following way: \r\n\r\n  * Simulate the query answering of q under ||SYMBOLTOKEN|| and D.\r\n\r\n  * If the answer of Stage 1 is positive, then nondeterministically copy disjuncts of q to generate the universal models. \r\n\r\n\r\nThe main challenges of implementing the above encoding are as follows. Firstly, instead of a single universal model, we need to generate a set of universal models in Stage 2. It is not clear whether the technique of generating universal model in ZhangZY16 can be applied to this situation. Secondly, to encode the computation in Stage 1, a successor relation is needed. But it seems  impossible to define such a relation in the language of DEDs explicitly.\r\n\r\nBelow we explain how to implement the encoding.\r\n\r\n Defining Successor and Arithmetic Relations.   \r\nTo implement the desired encoding, a successor relation needs to be defined so that the constants in the underlying database D can be ranged over. \r\nAs there is no negation in the body of DEDs, it seems impossible to construct DEDs to traverse ALL constants in adom(D). Fortunately, thanks to the closure of OMQA-ontologies under injective database homomorphisms, we do not need a successor relation on the full domain. The reason is as follows. Suppose we want to show that a query q is derivable from the database D under some ontology O. As O is closed under injective database homomorphisms,  it is equivalent to show  whether there is a subset A of adom(D) such that q is derivable from ||SYMBOLTOKEN|| under O.\r\n\r\nTo range over subsets of adom(D), we employ the  partial successor relations on adom(D), each of which is a successor relation on some subset of adom(D). Clearly, there is a partial successor relation for each subset A of adom(D). With the mentioned property, we will define some DEDs to generate partial successor relations on adom(D). To check whether q is derivable from D under O, it would be sufficient to test whether the computation of Stage 1 halts with \"accept\" under a certain partial successor relation.\r\n\r\nOur method to generate partial successor relations was inspired by RudolphT2015's technique to define successor relations in the language of TGDs RudolphT2015. In that paper they showed that every homomorphism-closed database query can be defined by a set of TGDs. It is worth noting that the ontology mediated queries focused on this paper are not necessary to be closed under homomorphisms. So their technique cannot be applied directly. \r\nFortunately, a linear order on adom(D) can be easily defined by a set of DEDs, and with this order, we are able to use their idea to generate all partial successor relations that are compatible with the defined order. Now we show how to implement this idea.\r\n\r\nLet AD be a unary relation symbol that will be interpreted as adom(D). Clearly, such a relation can be easily defined by some DEDs.\r\nWith the relation AD, a linear order relation Less over AD can then be defined in a routine way: \r\nAD(x)\u2227AD(y)\u2192Less(x,y)\u2228 ||SYMBOLTOKEN|| generate all partial successor relations compatible with Less, we link each constant c in adom(D) with a  alias a by the relation Link(c,a). Suppose ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| are aliases of constant  ||SYMBOLTOKEN|| and ||SYMBOLTOKEN|| respectively, by ||SYMBOLTOKEN|| we mean that ||SYMBOLTOKEN|| is the immediate successor of ||SYMBOLTOKEN|| in the underlying successor relation. The head (resp., the tail) of a partial successor relation is denoted by First(a) (resp., Last(b)). In particular, we use a as the  name of the underlying relation. Every partial successor relation is required to have a head and a tail. To generate these relations, we use the following ||SYMBOLTOKEN|| v ||SYMBOLTOKEN|| v Link(x,v)\u2227Last(v)\u2227Partial(v)\r\nLess(x,y&)\u2227Link(y,v)\u2227Partial(v)\r\n\r\n&\u2192 ||SYMBOLTOKEN|| u Link(x,u)\u2227Next(u,v)\u2227First(u)\r\n\r\nLess(x,y&)\u2227Link(y,v)\u2227Partial(v)\r\n\r\n&\u2192 ||SYMBOLTOKEN|| u Link(x,u)\u2227Next(u,v)\u2227Partial(u)\r\n\r\nTo understand how these DEDs work in more detail, please refer to the following example.\r\n\r\n", {}]}]}	An ontology language for ontology mediated query answering (OMQA-language) is universa  for a family of OMQA-languages if it is the most expressive one among this family. In this paper, we focus on three families of tra table OMQAlanguages, including first-order rewritable languages and languages whose data complexity of the query answering is in ||SYMBOLTOKEN|| or PTIME. On the negative side, we prove that there is, in general, no universal language for each of these families of languages. On the positive side, we propose a novel property, the locality, to approximate the first-order rewritability, and show that there exists a language of disjunctive em edded dependencies that is universal for the family of OMQA-languages with locality. All of these results apply to OMQA with query languages such as conjunctive queries, unions of conjunctive queries and acyclic conjunctive queries.
